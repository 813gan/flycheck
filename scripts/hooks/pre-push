#!/usr/bin/env python
# -*- coding: utf-8; -*-

from __future__ import print_function

import sys
import os
import subprocess


class Failed(Exception):
    def __init__(self, reason):
        self.reason = reason


def log(message):
    print(message, file=sys.stderr, end='')


def run_tests(logfile):
    subprocess.check_call(['make', 'vagrant-test'], stdout=logfile,
                          stderr=subprocess.STDOUT, bufsize=0)


def is_info_manual_current():
    output = subprocess.check_output(['git', 'status', '--porcelain',
                                      'doc/flycheck.texi'])
    return 'doc/flycheck.texi' not in output


def build_docs(logfile):
    subprocess.check_call(['vagrant', 'ssh', '-c', 'make -C /flycheck doc'],
                          stdout=logfile, stderr=subprocess.STDOUT, bufsize=0)
    if not is_info_manual_current():
        raise Failed('Texinfo manual not up to date.  Please commit doc/flycheck.texi!')


def check_dirty(logfile):
    output = subprocess.check_output(['git', 'status', '--porcelain'])
    if output.strip():
        logfile.write(output)
        raise Failed('You have uncommmitted changes.')


def main():
    testlog = os.path.abspath('testlog')
    for line in sys.stdin:
        _, _, remote_ref, _ = line.split()
        if remote_ref != 'refs/heads/master':
            # Don't force tests on feature branches
            continue
        log('Pushing to master!\n')

        # Disable buffering, to support tail -f logfile
        with open(testlog, 'wb', buffering=1) as logfile:
            for message, action in [('Checking working copy', check_dirty),
                                    ('Building docs', build_docs),
                                    ('Running tests', run_tests)]:
                log(message)
                log('...')
                try:
                    action(logfile)
                    log(' ok\n')
                except (subprocess.CalledProcessError, Failed) as error:
                    log(' FAILED\n')
                    reason = (error.reason if isinstance(error, Failed)
                              else 'Command {0} failed with code {1}.'.format(
                                      error.cmd, error.returncode))
                    log(reason + '\n')
                    log('See {0} for details\n'.format(testlog))
                    return 1

        # Remove the logfile if no errors occurred
        os.unlink(testlog)

    return 0


if __name__ == '__main__':
    try:
        sys.exit(main())
    except KeyboardInterrupt:
        log('Interrupted, not finishing push\n')
